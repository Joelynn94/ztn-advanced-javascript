ADVANCED
JAVASCRIPT
CONCEPTS
CHEAT SHEET
Zero To Mastery

Link to website
v 10

HEEELLLOOOOO!
I’m Andrei Neagoie, Founder and Lead Instructor of the Zero To Mastery Academy.
We ini ally created this JavaScript Cheat Sheet for Zero To Mastery students taking
our JavaScript: The Advanced Concepts course where they learn modern, advanced JavaScript
prac ces and grow to be in the top 10% of JavaScript developers. We are now making this
available to help all web developers learn and remember common JavaScript concepts.
If you're just star ng to learn JavaScript, congrats! Being a web developer is a fantas c career
op on and industry demand for JavaScript developers is HUGE. Check out my Complete Web
Developer Coding Bootcamp course to learn everything you need to know to become a web
developer.
Already a web developer but stuck in a junior or intermediate role? We can fast track you to get
the knowledge that Senior Javascript Developers have in just 30 days. By the end of
our JavaScript: The Advanced Concepts course, you'll be in the top 10% of JavaScript
Programmers.
Start learning for free with over one hour of free lessons by visi ng the course links above and
click PREVIEW next to the lessons.
Happy Coding!
Andrei

Founder & Lead Instructor, Zero To Mastery
Andrei Neagoie

P.S. I also recently wrote a book called Principles For Programmers. You can download the
first five chapters for free here.

ti

ti

ti

ti

ti

ti

Link to website

CREDITS
A huge thanks and credit goes to Zero To Mastery student and Star Mentor, Bri ney,
from her notes while taking and comple ng the JavaScript: The Advanced Concepts
course. Check out some of Bri ney's other fantas c notes on a variety of topics.

tt

ti

ti

tt

Link to website

CONTENTS
JavaScript Engine
The Parser, The AST, The Interpreter, The Compiler, The Combo

Wri ng Op mized Code
Memoiza on, Inline Caching, Hidden Classes, Managing Arguments

Call Stack and Memory Heap
Memory Heap, Call Stack

Stack Over ow
Garbage Collec on, Synchronous, Event Loop and Callback Queue, Job
Queue, 3 Ways to Promise, Threads, Concurrency, and Parallelism

Execu on Context
Global Execu on Context, Func on Execu on Context, Arrow Func ons

Hois ng
Link to website
ti

ti

Page 1 of 93

ti

ti

fl

ti

ti

ti

ti

ti

ti

Go Back to Table of Contents

Lexical Environment
Scope Chain
Func on and Block Scope
IIFE - Immediately Invoked Func on
Expression
This
Lexical vs Dynamic Scope

Call, Apply, Bind
Call, Apply, Bind, Currying with bind

JavaScript Types
Objects in JavaScript, Primi ve vs Non Primi ve, Type Coercion, Sta c vs
Dynamic Typed

Link to website
ti

ti

Page 2 of 93

ti

ti

ti

Go Back to Table of Contents

The 2 Pillars: Closures and Prototypes
Func on Constructor, Prototypal Inheritance, Prototype vs proto, Callable
Object, Higher Order Func ons, Closures, Memory E cient, Encapsula on

Object Oriented Programming
Object Oriented Programming, Factory
Func ons, Stores, Object.create, Constructor Func ons, Class, Private and
public elds

4 Pillars of OOP
Func onal Programming
Pure Func ons, Referen al transparency, Idempotence, Impera ve vs
Declara ve, Immutability, Par al Applica on, Pipe and Compose, Arity

Composi on vs Inheritance
OOP Problems, Finally

Modules in JavaScript
Module Pa erns, Issues With Modules, ES6 Modules

Link to website
ti

ti

ffi

ti

ti

Page 3 of 93

ti

ti

ti

ti

tt

ti

ti

ti

fi

ti

ti

Go Back to Table of Contents

Error Handling
The End...
Data Structures & Algorithms
Data Structures, How do computers work?, Popular Data
Structures, Arrays, Implemen ng an Array, Hash tables, Hash
Collisions, Hashing in JavaScript, Create a Hash Table

Credits

ti

Go Back to Table of Contents

Page 4 of 93

Link to website

COURSE MAP

Course Map

Go Back to Table of Contents

Page 5 of 93

JAVASCRIPT ENGINE
A JavaScript engine is a computer program that you give JavaScript code to and it tells
the computer how to execute it. Basically a translator for the computer between
JavaScript and a language that the computer understands. But what happens inside of
the engine? Well, that depends on the engine. There are many JavaScript Engines out
there and typically they are created by web browser vendors. All engines are
standardized by ECMA Script or ES.
List of JavaScript Engines

Ni y Snippet: 2008 was a pivotal moment for JavaScript when Google
created the Chrome V8 Engine. The V8 engine is an open source highperformance JavaScript engine, wri en in C++ and used in the Chrome
browser and powers Node JS. The performance outmatched any engine that
came before it mainly because it combines 2 parts of the engine, the
interpreter and the compiler. Today, all major engines use this same
technique.

Page 6 of 93

tt

ft

Go Back to Table of Contents

THE PARSER
Parsing is the process of analyzing the source code, checking it for errors, and breaking it
up into parts.

THE AST
The parser produces a data structure called the Abstract Syntax Tree or AST. AST is a
tree graph of the source code that does not show every detail of the original syntax, but
contains structural or content-related details. Certain things are implicit in the tree and
do not need to be shown, hence the tle abstract.

THE INTERPRETER
An interpreter directly executes each line of code line by line, without requiring them to
be compiled into a machine language program. Interpreters can use di erent strategies
to increase performance. They can parse the source code and execute it immediately,
translate it into more e cient machine code, execute precompiled code made by a
compiler, or some combina on of these. In the V8 engine, the interpreter outputs
bytecode.
Ni y Snippet: The rst JavaScript engine was wri en by Brendan Eich, the
creator of JavaScript, in 1995 for the Netscape navigator web browser.
Originally, the JavaScript engine only consisted of an interpreter. This later
evolved into the SpiderMonkey engine, s ll used by the Firefox browser.

THE COMPILER
The compiler works ahead of me to convert instruc ons into a machine-code or lowerlevel form so that they can be read and executed by a computer. It runs all of the code
and tries to gure out what the code does and then compiles it down into another
language that is easier for the computer to read. Have you heard of Babel or TypeScript?
They are heavily used in the Javascript ecosystem and you should now have a good idea

ff

ti

tt

ti

Page 7 of 93

ti

ti

ti

ffi

fi

fi

ft

Go Back to Table of Contents

of what they are. Babel is a Javascript compiler that takes your modern JS code and
returns browser compa ble JS (older JS code). Typescript is a superset of Javascript that
compiles down to Javascript. Both of these do exactly what compilers do. Take one
language and convert into a di erent one!

THE COMBO
In modern engines, the interpreter starts reading the code line by line while
the pro ler watches for frequently used code and ags then passes is to the compiler to
be op mized. In the end, the JavaScript engine takes the bytecode the interpreter
outputs and mixes in the op mized code the compiler outputs and then gives that to the
computer. This is called "Just in Time" or JIT Compiler.
Ni y Snippet: Back in 1995 we had no standard between the browsers for
compiling JavaScript. Compiling code on the browser or even ahead of me
was not feasible because all the browsers were compe ng against each
other and could not agree on an executable format. Even now, di erent
browsers have di erent approaches on doing things. Enter WebAssembly a
standard for binary instruc on (executable) format. Keep your eye on
WebAssembly to help standardize browsers abili es to execute JavaScript in
the future! WebAssemby

WRITING OPTIMIZED CODE
We want to write code that helps the compiler make its op miza ons, not work against
it making the engine slower.

Memoiza on
Memoiza on is a way to cache a return value of a func on based on its parameters. This
makes the func on that takes a long me run much faster a er one execu on. If the
parameter changes, it will s ll have to reevaluate the func on.

ti

ti

ff

ti

ft

ti

ti

ti

ti

fl

ti

Page 8 of 93

ti

ff

ti

ti

ti

ti

ff

ti

ti

ti

fi

ti

ft

Go Back to Table of Contents

// Bad Way
function addTo80(n) {
console.log('long time...')
return n + 80
}
addTo80(5)
addTo80(5)
addTo80(5)
// long time... 85
// long time... 85
// long time... 85
// Memoized Way
functions memoizedAddTo80() {
let cache = {}
return function(n) { // closure to access cache obj
if (n in cache) {
return cache[n]
} else {
console.log('long time...')
cache[n] = n + 80
return cache[n]
}
}
}
const memoized = memoizedAddTo80()
console.log('1.',
console.log('2.',
console.log('3.',
console.log('4.',
//
//
//
//
//
//

memoized(5))
memoized(5))
memoized(5))
memoized(10))

long time...
1. 85
2. 85
3. 85
long time...
4. 90

Here are a few things you should avoid when wri ng your code if possible:
• eval()
• arguments
• for in
Page 9 of 93

ti

Go Back to Table of Contents

• with
• delete
There are a few main reasons these should be avoided.
JavaScript Hidden Classes and Inline Caching in V8
Managing Arguments

Inline Caching
function findUser(user) {
return `found ${user.firstName} ${user.lastName}`
}
const userData = {
firstName: 'Brittney',
lastName: 'Postma'
}
findUser(userData)
// if this findUser(userData) is called multiple times,
// then it will be optimized (inline cached) to just be 'found Brittney Postma'

If this code gets op mized to return only 1 name, then the computer would have to do a
lot more work if you needed to return a di erent user.

Hidden Classes
function Animal(x, y) {
this.x = x;
this.y = y;
}
const obj1 = new Animal(1, 2);
const obj2 = new Animal(3, 4);
obj1.a
obj1.b
obj2.b
obj2.a

=
=
=
=

30;
100;
30;
100;

Page 10 of 93

ff

ti

Go
Backobj1.x
to Table= of30;
Contents
delete

By se ng these values in a di erent order than they were instan ated, we are making
the compiler slower because of hidden classes. Hidden classes are what the compiler
uses under the hood to say that these 2 objects have the same proper es. If values are
introduced in a di erent order than it was set up in, the compiler can get confused and
think they don't have a shared hidden class, they are 2 di erent things, and will slow
down the computa on. Also, the reason the delete keyword shouldn't be used is
because it would change the hidden class.
// This is the more optimized version of the code.
function Animal(x, y) {
// instantiating a and b in the constructor
this.a = x;
this.b = y;
}
const obj1 = new Animal(1, 2);
const obj2 = new Animal(3, 4);
// and
obj1.a
obj1.b
obj2.a
obj2.b

setting the values in order
= 30;
= 100;
= 30;
= 100;

Managing Arguments
There are many ways using arguments that can cause a func on to be unop mizable. Be
very careful when using arguments and remember:
Safe Ways to Use Arguments
arguments.length
arguments[i] when i is a valid integer
NEVER use arguments directly without .length or [i]
STRICTLY fn.apply(y, arguments) is ok

ti

ti

ti

Page 11 of 93

ti

ff

ti

ff

tti

Go Back to Table of Contents

ff

•
•
•
•

CALL STACK AND MEMORY HEAP
The JavaScript engine does a lot of work for us, but 2 of the biggest jobs are reading and
execu ng it. We need a place to store and write our data and a place to keep track line
by line of what's execu ng. That's where the call stack and the memory heap come in.

Memory Heap
The memory heap is a place to store and write informa on so that we can use our
memory appropriately. It is a place to allocate, use, and remove memory as needed.
Think of it as a storage room of boxes that are unordered.
// tell the memory heap to allocate memory for a number
const number = 11;
// allocate memory for a string
const string = "some text";
// allocate memory for an object and it's values
const person = {
first: "Brittney",
last: "Postma"
};

Page 12 of 93

ti

ti

ti

Go Back to Table of Contents

The call stack keeps track of where we are in the code, so we can run the program in
order.
function subtractTwo(num) {
return num - 2;
}
function calculate() {
const sumTotal = 4 + 5;
return subtractTwo(sumTotal);
}
debugger;
calculate();

Things are placed into the call stack on top and removed as they are nished. It runs in a
rst in last out mode. Each call stack can point to a loca on inside the memory heap. In
the above snippet the call stack looks like this (see next page).

Page 13 of 93

fi

Go Back to Table of Contents

ti

fi

Call Stack

anonymous; // file is being ran
// CALL STACK
// hits debugger and stops the file
// step through each line
calculate(
// steps through calculate() sumTotal = 9
anonymous
);
// CALL STACK
// steps into subtractTwo(sumTotal) num = 9
subtractTwo; // returns 9 - 2
calculate(anonymous);
// CALL STACK
// subtractTwo() has finished and has been removed
calculate(
// returns 7
anonymous
)(
// CALL STACK
// calculate() has finished and has been removed
anonymous
);
// CALL STACK
// and finally the file is finished and is removed
// CALL STACK

Go Back to Table of Contents

Page 14 of 93

STACK OVERFLOW
So what happens if you keep calling func ons that are nested inside each other? When
this happens it’s called a stack over ow.
// When a function calls itself,
// it is called RECURSION
function inception() {
inception();
}
inception();
// returns Uncaught RangeError:
// Maximum call stack size exceeded

Ni y Snippet: Did you know, Google has hard-coded recursion into their
program to throw your brain for a loop when searching recursion?

Garbage Collec on
JavaScript is a garbage collected language. If you allocate memory inside of a func on,
JavaScript will automa cally remove it from the memory heap when the func on is done
being called. However, that does not mean you can forget about memory leaks. No
system is perfect, so it is important to always remember memory management.
JavaScript completes garbage collec on with a mark and sweep method.

ti

ti

ti

fl

Page 15 of 93

ti

ti

ti

ft

Go Back to Table of Contents

Mark and Sweep Method

var person = {
first: "Brittney",
last: "Postma"
};
person = "Brittney Postma";

In the example above a memory leak is created. By changing the variable person from
an object to a string, it leaves the values of rst and last in the memory heap and does
not remove it. This can be avoided by trying to keep variables out of the global
namespace, only instan ate variables inside of func ons when possible. JavaScript is
a single threaded language, meaning only one thing can be executed at a me. It only
has one call stack and therefore it is a synchronous language.

ti

ti

Page 16 of 93

fi

ti

Go Back to Table of Contents

Synchronous
So, what is the issue with being a single threaded language? Lets's start from the
beginning. When you visit a web page, you run a browser to do so (Chrome, Firefox,
Safari, Edge). Each browser has its own version of JavaScript Run me with a set of Web
API's, methods that developers can access from the window object. In a synchronous
language, only one thing can be done at a me. Imagine an alert on the page, blocking
the user from accessing any part of the page un l the OK bu on is clicked. If everything
in JavaScript that took a signi cant amount of me, blocked the browser, then we would
have a pre y bad user experience. This is where concurrency and the event loop come
in.

Event Loop and Callback Queue
When you run some JavaScript code in a browser, the engine starts to parse the code.
Each line is executed and popped on and o the call stack. But, what about Web API's?
Web API's are not something JavaScript recognizes, so the parser knows to pass it o to
the browser for it to handle. When the browser has nished running its method, it puts
what is needed to be ran by JavaScript into the callback queue. The callback queue
cannot be ran un l the call stack is completely empty. So, the event loop is constantly
checking the call stack to see if it is empty so that it can add anything in the callback
queue back into the call stack. And nally, once it is back in the call stack, it is ran and
then popped o the stack.

ff

ti

tt

fi

ti

ti

ff

ti

Page 17 of 93

fi

fi

ti

ff

tt

Go Back to Table of Contents

console.log("1");
// goes on call stack and runs 1
setTimeout(() => {
console.log("2"), 1000;
});
// gets sent to web api
// web api waits 1 sec, runs and sends to callback queue
// the javascript engine keeps going
console.log("3");
// goes on call stack and runs 3
// event loop keeps checking and see call stack is empty
// event loop sends calback queue into call stack
// 2 is now ran
// 1
// 3
// 2
// Example with 0 second timeout
console.log("1");
setTimeout(() => {
console.log("2"), 0;
});
console.log("3");
// 1
// 3
// 2
// Still has the same output

In the last example, we get the same output. How does this work if it waits 0 seconds?
The JavaScript engine will s ll send o the setTimeout() to the Web API to be ran and it
will then go into the callback queue and wait un l the call stack is empty to be ran. So,
we end up with the exact same end point.

ti

Page 18 of 93

ff

ti

Go Back to Table of Contents

JS Run me Playground

What the heck is the event loop anyway? | Philip Roberts | JSConf EU (link to YouTube)

Ni y Snippet: Un l 2009, JavaScript was only run inside of the browser.
That is when Ryan Dahl decided it would be great if we could use JavaScript
to build things outside the browser. He used C and C++ to build an
executable (exe) program called Node JS. Node JS is a JavaScript run me
environment built on Chrome's V8 engine that uses C++ to provide the event
loop and callback queue needed to run asynchronous opera ons.

ti

Page 19 of 93

ti

ti

ti

ft

Go Back to Table of Contents

2020 Update = Deno

10 Things I Regret About Node.js - Ryan Dahl (link to YouTube)

The very same Ryan Dahl then gave a talk back in 2018, 10 Things I Regret About
Node.js which led to the recent release of his new (and improved) JavaScript and
TypeScript called Deno which aims to provide a produc ve and secure scrip ng
environment for the modern programmer. It is built on top of V8, Rust, and TypeScript.
If you're interested in learning Deno, Zero To Mastery instructors, Andrei
Neagoie and Adam Odziemkowski (also an o cial Deno contributor), released the
very rst comprehensive Deno course.

ti

ti

Page 20 of 93

ffi

fi

Go Back to Table of Contents

Job Queue
The job queue or microtask queue came about with promises in ES6. With promises we
needed another callback queue that would give higher priority to promise calls. The
JavaScript engine is going to check the job queue before the callback queue.
// 1 Callback Queue ~ Task Queue
setTimeout(() => {
console.log("1", "is the loneliest number");
}, 0);
setTimeout(() => {
console.log("2", "can be as bad as one");
}, 10);
// 2 Job Queue ~ Microtask Queue
Promise.resolve("hi").then(data => console.log("2", data));
// 3
console.log("3", "is a crowd");
//
//
//
//
//

3 is a crowd
2 hi
undefined Promise resolved
1 is the loneliest number
2 can be as bad as one

Go Back to Table of Contents

Page 21 of 93

3 Ways to Promise
There are 3 ways you could want promises to resolve, parallel (all together), sequen al
(1 a er another), or a race (doesn't ma er who wins).
const promisify = (item, delay) =>
new Promise(resolve => setTimeout(() => resolve(item), delay));
const a = () => promisify("a", 100);
const b = () => promisify("b", 5000);
const c = () => promisify("c", 3000);
async function parallel() {
const promises = [a(), b(), c()];
const [output1, output2, output3] = await Promise.all(promises);
return `parallel is done: ${output1} ${output2} ${output3}`;
}
async function sequence() {
const output1 = await a();
const output2 = await b();
const output3 = await c();
return `sequence is done: ${output1} ${output2} ${output3}`;
}
async function race() {
const promises = [a(), b(), c()];
const output1 = await Promise.race(promises);
return `race is done: ${output1}`;
}
sequence().then(console.log);
parallel().then(console.log);
race().then(console.log);
// race is done: a
// parallel is done: a b c
// sequence is done: a b c

ti

Page 22 of 93

tt

ft

Go Back to Table of Contents

Threads, Concurrency, and Parallelism
Even though JavaScript is a single threaded language, there are worker threads that
work in the background that don't block the main thread. Just like a browser creates a
new thread when you open a new tab. The workers work through messages being sent,
but don't have access to the full program.
Web Workers
Scaling NodeJS
Mul threading
var worker = new Worker("worker.js");
worker.postMessage("Helloooo");

addEventListener("message");

EXECUTION CONTEXT
Code in JavaScript is always ran inside a type of execu on context. Execu on context is
simply the environment within which your code is ran. There are 2 types of execu on
context in JavaScript, global or func on. There are 2 stages as well to each context, the
crea on and execu ng phase. As the JavaScript engine starts to read your code, it
creates something called the Global Execu on Context.

Global Execu on Context
Crea on Phase
1. Global object created
2. Ini alizes this keyword to global

ti

ti

ti

ti

Page 23 of 93

ti

ti

ti

ti

ti

ti

ti

Go Back to Table of Contents

Execu ng Phase
3. Variable Environment created - memory space for var variables and func ons
created
4. Ini alizes all variables to unde ned (also known as hois ng) and places them
with any func ons into memory
this;
window;
this === window;
// Window {...}
// Window {...}
// true

Func onal Execu on Context
A func on context is created by the JavaScript engine when it sees a func on call. Each
func on gets its own execu on context.
Crea on Phase
1. Argument object created with any arguments
2. Sets this to the global object unless in strict mode, where it’s unde ned
Execu ng Phase
3. Variable Environment created - memory space for variable and func ons created
4. Ini alizes all variables to unde ned and places them into memory with any new
func ons

ti

ti

ti

fi

Page 24 of 93

ti

fi

fi

ti

ti

ti

ti

ti

ti

ti

ti

ti

ti

ti

ti

Go Back to Table of Contents

// Function Execution Context creates arguments object
function showArgs(arg1, arg2) {
console.log('arguments: ', arguments);
return `argument 1 is: ${arg1} and argument 2 is: ${arg2}`;
}
showArgs("hello", "world");
// arguments: { 0: 'hello', 1: 'world' }
// argument 1 is hello and argument 2 is world
function noArgs() {
console.log('arguments: ', arguments);
}
noArgs();
// arguments: {}
// even though there are no arguments, the object is still created

function showArgs(arg1, arg2) {
console.log("arguments: ", arguments);
console.log(Array.from(arguments));
}
showArgs("hello", "world");
// arguments: { 0: 'hello', 1: 'world' }
// [ 'hello', 'world' ]
function showArgs2(...args) {
console.log(console.log("arguments: ", args));
console.log(Array.from(arguments));
return `${args[0]} ${args[1]}`;
}
showArgs2("hello", "world");
// arguments: [ 'hello', 'world' ]
// [ 'hello', 'world' ]
// hello world

Go Back to Table of Contents

Page 25 of 93

The keyword arguments can be dangerous to use in your code as is. In ES6, a few
methods were introduced that can help be er use arguments.

Arrow Func ons
Some people think of arrow func ons as just being syntac c sugar for a
regular func on, but arrow func ons work a bit di erently than a regular
func on. They are a compact alterna ve to a regular func on, but also
without its own bindings to this, arguments, super,
or new.target keywords. Arrow func ons cannot be used as constructors
and are not the best op on for methods.
var obj = {
// does not create a new scope
i: 10,
b: () => console.log(this.i, this),
c: function() {
console.log(this.i, this);
}
};
obj.b(); // prints undefined, Window {...} (or the global object)
obj.c(); // prints 10, Object {...}```

HOISTING
Hois ng is the process of pu ng all variable and func on declara ons into memory
during the compile phase. In JavaScript, func ons are fully hoisted, var variables are
hoisted and ini alized to unde ned, and let and const variables are hoisted but not
ini alized a value. Var variables are given a memory alloca on and ini alized a value of
unde ned un l they are set to a value in line. So if a var variable is used in the code
before it is ini alized, then it will return unde ned. However, a func on can be called
from anywhere in the code base because it is fully hoisted. If let and const are used

ti

ti

ti

ti

ti

ti

ti

ff

ti

fi

tt

ti

Page 26 of 93

ti

ti

ti

fi

tti

ti

ti

ti

ti

ti

ti

fi

ti

ti

ti

Go Back to Table of Contents

// function expression gets hoisted as undefined
var sing = function() {
console.log("uhhhh la la la");
};
// function declaration gets fully hoisted
function sing2() {
console.log("ohhhh la la la");
}

// function declaration gets hoisted
function a() {
console.log("hi");
}
// function declaration get rewritten in memory
function a() {
console.log("bye");
}
console.log(a());
// bye

// variable declaration gets hoisted as undefined
var favoriteFood = "grapes";
// function expression gets hoisted as undefined
var foodThoughts = function() {
// new execution context created favoriteFood = undefined
console.log(`Original favorite food: ${favoriteFood}`);
// variable declaration gets hoisted as undefined
var favoriteFood = "sushi";
console.log(`New favorite food: ${favoriteFood}`);
};
foodThoughts();

before they are declared, then they will throw a reference error because they have not
Go Back to Table of Contents

Page 27 of 93

yet been ini alized (con nued on next page).

TAKEAWAYS
Avoid hois ng when possible. It can cause memory leaks and hard to catch
bugs in your code. Use let and const as your go to variables.

LEXICAL ENVIRONMENT
A lexical environment is basically the scope or environment the engine is currently
reading code in. A new lexical environment is created when curly brackets {} are used,
even nested brackets {{...}} create a new lexical environment. The execu on context tells
the engine which lexical environment it is currently working in and the lexical scope
determines the available variables.
function one() {
var isValid = true; // local env
two(); // new execution context
}
function two() {
var isValid; // undefined
}
var isValid = false; // global
one();
/*
two() isValid = undefined
one() isValid = true
global() isValid = false
-----------------------call stack
*/

Page 28 of 93

ti

ti

ti

ti

Go Back to Table of Contents

SCOPE CHAIN

Each environment context that is created has a link outside of its lexical environment
called the scope chain. The scope chain gives us access to variables in the parent
environment (con nued on next page).

ti

Go Back to Table of Contents

Page 29 of 93

var x = "x";
function findName() {
console.log(x);
var b = "b";
return printName();
}
function printName() {
var c = "c";
return "Brittney Postma";
}
function sayMyName() {
var a = "a";
return findName();
}
sayMyName();
//
//
//
//
//
//

sayMyName runs a = 'a'
findName runs
x
b = 'b'
printName runs c = 'c'
Brittney Postma

In this example, all the func ons have access to the global variable x, but trying to access
a variable from another func on would return an error. The example below will show
how the scope chain links each func on.

Page 30 of 93

ti

ti

ti

Go Back to Table of Contents

function sayMyName() {
var a = "a";
console.log(b, c); // returns error
return function findName() {
var b = "b";
console.log(a); // a
console.log(c); // returns error
return function printName() {
var c = "c";
console.log(a, b); // a, b
};
};
}
sayMyName()()(); //each function is returned and has to be called

In this example, you can see that the func ons only get access to the variables in their
parent container, not a child. The scope chain only links down the call stack, so you
almost have to think of it in reverse. It goes up to the parent, but down the call stack.

Go Back to Table of Contents

ti

Page 31 of 93

JavaScript is Weird
// It asks global scope for height.
// Global scope says: ummm... no but here I just created it for you.
// We call this leakage of global variables.
// Adding 'use strict' to the file prevents this and causes an error.
function weird() {
height = 50;
}
var heyhey = function doodle() {
// code here
};
heyhey();
doodle(); // Error! because it is enclosed in its own scope.

Go Back to Table of Contents

Page 32 of 93

FUNCTION AND BLOCK SCOPE
Most programming languages are block scoped, meaning every me you see a new { }
(curly braces) is a new lexical environment. However, JavaScript is func on scoped,
meaning it only creates a new local environment if it sees the keyword func on on the
global scope. To give us access to block scope, in ES6 let and const were added to the
language. Using these can prevent memory leaks, but there is s ll an argument to be
made for using var.
//Function Scope
function loop() {
for (var i = 0; i < 5; i++) {
console.log(i);
}
console.log("final", i); // returns final 5
}
//Block Scope
function loop2() {
for (let i = 0; i < 5; i++) {
// can access i here
}
console.log("final", i); // returns an error here
}
loop();
/*
1
2
3
4
final 5
*/
loop2();
// ReferenceError: i is not defined

ti

ti

ti

Page 33 of 93

ti

Go Back to Table of Contents

LET AND CONST
Variable declara ons with let and const work di erently from
the var variable declara on and I wanted to take a minute to explain. When
a lexical scope is entered and the execu on context is created, the engine
allocates memory for any var variable in that scope and ini alizes it to
unde ned. The let and const variables only get ini alized on the line they
are executed on and only get allocated unde ned if there is no assignment
to the variable. Trying to access a let or const variable before it is declared
or outside of its block without returning it will result in a Reference Error.

IIFE - IMMEDIATELY INVOKED FUNCTION
EXPRESSION
Immediately Invoked Func on Expression or more simply IIFE is a JavaScript func on
that runs as soon as it is de ned. Can also be referred to as a Self-Execu ng Anonymous
Func on.
// Grouping Operator () creates a lexical scope
(function() {
// statements
})();
// Immediately invokes the function with 2nd set of ()

Takeaways: Avoid pollu ng the global namespace or scope when possible.

ti

ti

ti

ti

ff

fi

Page 34 of 93

ti

fi

ti

ti

ti

ti

fi

ti

Go Back to Table of Contents

THIS

Here we are…
The moment has arrived, me to talk about this. What is this? Why is this so confusing?
For some, this is the scariest part of JavaScript. Well, hopefully we can clear some things
up.
this is the object that the func on is a property of
There that's simple right? Well, maybe not, what does that mean? Back in Execu on
Context, we talked about how the JavaScript engine creates the global execu on context
and ini alizes this to the global window object.
this; // Window {...}
window; // Window {...}
this === window; // true
function a() {
console.log(this);
}
a();
// Window {...}

ti

Page 35 of 93

ti

ti

ti

ti

Go Back to Table of Contents

In the example above, it is easy to understand that this is equal to the window object,
but what about inside of func on a? Well, what object is func on a apart of? In the dev
tools, if you expand the window object and scroll down the list, you will see a() is a
method on the window object. By calling a(), you are essen ally saying window.a() to
the console.
const obj = {
property: `I'm a property of obj.`,
method: function() {
// this refers to the object obj
console.log(this.property);
}
};
obj.method();
// I'm a property of obj.

this refers to whatever is on the le of the . (dot) when calling a method
// obj is to the left of the dot
obj.method();

S ll confused? Try this:
function whichName() {
console.log(this.name);
}
var name = "window";
const obj1 =
name: "Obj
whichName
};
const obj2 =
name: "Obj
whichName
};

{
1",

{
2",

whichName(); // window
obj1.whichName(); // Obj 1
obj2.whichName(); // Obj 2

ti

Page 36 of 93

ti

ft

ti

ti

Go Back to Table of Contents

Another way to look at this is to check which object called it.
const a = function() {
console.log("a", this);
const b = function() {
console.log("b", this);
const c = {
hi: function() {
console.log("c", this);
}
};
c.hi(); // new obj c called function
};
b(); // ran by a window.a(b())
};
a(); // called by window
// a Window {…}
// b Window {…}
// c {hi: ƒ}

Here is this 4 ways:
• new keyword binding - the new keyword changes the meaning of this to be the
object that is being created.
• implicit binding - "this" refers to the object that is calling it. It is implied, without
doing anything it's just how the language works.
• explicit binding - using the "bind" keyword to change the meaning of "this".
• arrow func ons as methods - "this" is lexically scoped, refers to it's current
surroundings and no further. However, if "this" is inside of a method's func on, it
falls out of scope and belongs to the window object. To correct this, you can use a
higher order func on to return an arrow func on that calls "this".

ti

Page 37 of 93

ti

ti

ti

Go Back to Table of Contents

// new binding
function Person(name, age) {
this.name = name;
this.age = age;
console.log(this);
}
const person1 = new Person("person1", 55);
// this = Person { name: 'person1', age: 55 }
//implicit binding
const person = {
name: "person",
age: 20,
hi() {
console.log("hi " + this);
}
};
person.hi();
// this = person { name: 'person', age: 20, hi(){...} }
//explicit binding
let name = "Brittney";
const person3 = {
name: "person3",
age: 50,
hi: function() {
console.log("hi " + this.name);
}.bind(window)
};
person3.hi();
// hi Brittney
// this = window {...}
// arrow functions inside objects
const person4 = {
name: "person4",
age: 40,
hi: function() {
var inner = () => {
console.log(this);
};
return inner();
}
};
person4.hi();
// this = person4 { name: 'person4', age: 40, hi() {...} }
// if either function is changed around, it doesn't work

Go Back to Table of Contents

Page 38 of 93

Lexical vs Dynamic Scope
A big gotcha for a lot of people working with *this is when a func on is ran inside of
another func on. It gets a li le confusing, but we can remember who called the
func on.
const obj = {
name: "Billy",
sing() {
console.log("a", this);
var anotherFunc = function() {
console.log("b", this);
};
anotherFunc();
}
};
obj.sing();
// a {name: "Billy", sing: ƒ}
// b Window {…}

In the example above, the obj called sing() and then anotherFunc() was called within the
sing() func on. In JavaScript, that func on defaults to the Window object. It happens
because everything in JavaScript is lexically scoped except for the this keyword. It
doesn't ma er where it is wri en, it ma ers how it is called. Changing anotherFunc()
instead to an arrow func on will x this problem, as seen below. Arrow func ons do not
bind or set their own context for this. If this is used in an arrow func on, it is taken from
the outside. Arrow func ons also have no arguments created as func ons do.
const obj = {
name: "Billy",
sing() {
console.log("a", this);
var anotherFunc = () => {
console.log("b", this);
};
anotherFunc();
}
};
obj.sing();
// a {name: "Billy", sing: ƒ}
// b {name: "Billy", sing: ƒ}

ti

ti

ti

ti

tt

Page 39 of 93

ti

fi

tt

tt

ti

ti

ti

tt

ti

ti

Go Back to Table of Contents

Okay, last example to really solidify our knowledge of this.
var b = {
name: "jay",
say() {
console.log(this);
}
};
var c = {
name: "jay",
say() {
return function() {
console.log(this);
};
}
};
var d = {
name: "jay",
say() {
return () => console.log(this);
}
};
b.say(); // b {name: 'jay', say()...}
// b called the function
c.say(); // function() {console.log(this)}
// returned a function that gets called later
c.say()(); // Window {...}
// c.say() gets the function and the Window runs it
d.say(); // () => console.log(this)
// returned the arrow function
d.say()(); // d {name: 'jay', say()...}
// arrow function does not rebind this and inherits this from parent

A er everything is said and done, using this can s ll be a bit confusing. If you aren't sure
what it's referencing, just console.log(this) and see where it's poin ng.

ti

Page 40 of 93

ti

ft

Go Back to Table of Contents

CALL, APPLY, BIND
Call
Call is a method of an object that can subs tute a di erent object than the one it is
wri en on.
const wizard = {
name: "Merlin",
health: 100,
heal(num1, num2) {
return (this.health += num1 + num2);
}
};
const archer = {
name: "Robin Hood",
health: 30
};
console.log(archer); // health: 30
wizard.heal.call(archer, 50, 20);
console.log(archer); // health: 100

In this example call is used to borrow the heal method from the wizard and is used on
the archer (which is actually poin ng this to archer), with the op onal arguments added.

Apply
Apply is almost iden cal to call, except that instead of a comma separated list of
arguments, it takes an array of arguments.
// instead of this
// wizard.heal.call(archer, 50, 20)
// apply looks like this
wizard.heal.apply(archer, [50, 20]);
// this has the same result

ti

ff

Page 41 of 93

ti

ti

ti

tt

Go Back to Table of Contents

Bind
Unlike call and apply, bind does not run the method it is used on, but rather returns a
new func on that can then be called later.
console.log(archer); // health: 30
const healArcher = wizard.heal.bind(archer, 50, 20);
healArcher();
console.log(archer); // health: 100

Currying With Bind
Currying is breaking down a func on with mul ple arguments into one or more
func ons that each accept a single argument.
function multiply(a, b) {
return a * b;
}
let multiplyByTwo = multiply.bind(this, 2);
multiplyByTwo(4); // 8
let multiplyByTen = multiply.bind(this, 10);
multiplyByTen(6); // 60

Exercise: Find the largest number in an array
const array = [1, 2, 3];
function getMaxNumber(arr) {
return Math.max.apply(null, arr);
}
getMaxNumber(array); // 3

Page 42 of 93

ti

ti

ti

ti

Go Back to Table of Contents

Exercise 2: How would you x this?
const character = {
name: "Simon",
getCharacter() {
return this.name;
}
};
const giveMeTheCharacterNOW = character.getCharacter;
//How Would you fix this?
console.log("?", giveMeTheCharacterNOW()); //this should return
'Simon' but doesn't
// ANSWER
// change this line
const giveMeTheCharacterNOW =
character.getCharacter.bind(character);
console.log("?", giveMeTheCharacterNOW()); // ? Simon

fi

Go Back to Table of Contents

Page 43 of 93

JAVASCRIPT TYPES
Bri ney goes into all of the types in her basic JavaScript course notes, but decided to
take a deeper dive into types in JavaScript here.
Type

Result

Unde ned
Null
Boolean
Number
BigInt (new in ECMAScript 2020)
String
Symbol (new in ECMAScript 2015)
Func on object
Any other object

unde ned
object*
boolean
number
bigint
string
symbol
function
object

*Null - Why does the typeof null return object? When JavaScript was rst
implemented, values were represented as a type tag and a value. The
objects type tag was 0 and the NULL pointer (0x00 in most pla orms)
consequently had 0 as a type tag as well. A x was proposed that would
have made typeof null === 'null', but it was rejected due to legacy code that
would have broken.
// Numbers
typeof 37 === "number";
typeof 3.14 === "number";
typeof 42 === "number";
typeof Math.LN2 === "number";
typeof Infinity === "number";
typeof NaN === "number"; // Despite being "Not-A-Number"
typeof Number("1") === "number"; // Number tries to parse things into numbers
typeof Number("shoe") === "number"; // including values that cannot be type coerced to a
number
typeof 42n === "bigint";

fi

tf

Page 44 of 93

fi

fi

ti

fi

tt

Go Back to Table of Contents

// Strings
typeof "" === "string";
typeof "bla" === "string";
typeof `template literal` === "string";
typeof "1" === "string"; // note that a number within a string is still typeof string
typeof typeof 1 === "string"; // typeof always returns a string
typeof String(1) === "string"; // String converts anything into a string, safer than toString
// Booleans
typeof true === "boolean";
typeof false === "boolean";
typeof Boolean(1) === "boolean"; // Boolean() will convert values based on if they're truthy or
falsy
typeof !!1 === "boolean"; // two calls of the ! (logical NOT) operator are equivalent to Boolean()
// Symbols
typeof Symbol() === "symbol";
typeof Symbol("foo") === "symbol";
typeof Symbol.iterator === "symbol";
// Undefined
typeof undefined === "undefined";
typeof declaredButUndefinedVariable === "undefined";
typeof undeclaredVariable === "undefined";
// Objects
typeof { a: 1 } === "object";
// use Array.isArray or Object.prototype.toString.call
// to differentiate regular objects from arrays
typeof [1, 2, 4] === "object";
typeof new Date() === "object";
typeof /regex/ === "object"; // See Regular expressions section for historical results
// The following are confusing, dangerous, and wasteful. Avoid them.
typeof new Boolean(true) === "object";
typeof new Number(1) === "object";
typeof new String("abc") === "object";
// Functions
typeof function() {} === "function";
typeof class C {} === "function";
typeof Math.sin === "function";

Go Back to Table of Contents

Page 45 of 93

Unde ned vs Null: Unde ned is the absence of de ni on, it has yet to be
de ned, and null is the absence of value, there is no value there.

Objects in JavaScript
Objects are one of the broadest types in JavaScript, almost "everything" is an
object. MDN Standard built-in objects
•
•
•
•
•
•
•
•
•

Booleans can be objects (if de ned with the new keyword)
Numbers can be objects (if de ned with the new keyword)
Strings can be objects (if de ned with the new keyword)
Dates are always objects
Maths are always objects
Regular expressions are always objects
Arrays are always objects
Func ons are always objects
Objects are always objects

Primi ve vs. Non Primi ve
Primi ve - Primi ve values are de ned by being immutable, they cannot be altered. The
variable assigned to a primi ve type may be reassigned to a new value, but the original
value can not be changed in the same way objects can be modi ed. Primi ves
are passed by value, meaning their values are copied and then placed somewhere else
in the memory. They are also compared by value. There are currently 7 primi ve data
types in JavaScript.
string
number
bigint
boolean
null
unde ned
symbol

ti

ti

fi

Page 46 of 93

ti

fi

fi

fi

ti

fi

ti

fi

ti

ti

fi

ti

fi

ti

fi

Go Back to Table of Contents

fi

•
•
•
•
•
•
•

Non Primi ve - The only type that leaves us with is objects. Objects are able to be
mutated and their proper es are passed by reference, meaning their proper es are not
stored separately in memory. A new variable poin ng to an object will not create a copy,
but reference the original objects loca on in memory. Therefore, changing the 2nd
object will also change the rst.
// objects are passed by reference
let obj = {
name: "object 1"
};
let newObj = obj; // points to same place in memory as obj
newObj.name = "newObj"; // modifies the memory
// Since both point to the same place...
console.log(obj); // {name: newObj}
console.log(newObj); // {name: newObj}
// They are both modified.
let arr = [1, 2, 3];
let newArr = arr;
newArr.push(4);
console.log(arr); // [1, 2, 3, 4]
console.log(newArr); // [1, 2, 3, 4]

There are two ways to get around this, Object.assign() or use the spread operator {...} to
"spread" or expand the object into a new variable. By doing this, it will allow the new
variable to be modi ed without changing the original. However, these only create a
"shallow copy".
Shallow copy: Shallow copy is a bit-wise copy of an object. A new object is
created that has an exact copy of the values in the original object. If any of
the elds of the object are references to other objects, just the reference
addresses are copied i.e., only the memory address is copied.
> Deep copy: A deep copy copies all elds, and makes copies of dynamically
allocated memory pointed to by the elds. A deep copy occurs when an
object is copied along with the objects to which it refers.
> Understanding Deep and Shallow Copy

ti

ti

ti

fi

Page 47 of 93

fi

fi

ti

fi

ti

fi

Go Back to Table of Contents

const originalObj = {
nested: {
nestedKey: "nestedValue"
},
key: "value"
};
// originalObj points to location 1 in memory
const assignObj = originalObj;
// assignObj will point to 1 in memory
const shallowObj = { ...originalObj };
// shallowObj points to a new location 2, but references location 1 for the nested
object
const deepObj = JSON.parse(JSON.stringify(originalObj));
// deepObj clones all parts of the object to a new memory address

Go Back to Table of Contents

Page 48 of 93

const originalObj = {
nested: {
nestedKey: "nestedValue"
},
key: "value"
};
const assignObj = originalObj;
const shallowObj = { ...originalObj };
const deepObj = JSON.parse(JSON.stringify(originalObj));
console.log("originalObj: ", originalObj);
console.log("assignObj: ", assignObj);
console.log("shallowObj: ", shallowObj);
console.log("deepObj: ", deepObj);
/*
originalObj: {nested: {
nestedKey: "changed value"
},
key: "changed value"}
assignObj: {nested: {
nestedKey: "changed value"
},
key: "changed value"}
shallowObj: {nested: {
nestedKey: "changed value"
},
key: "value"}
deepObj: {nested: {
nestedKey: "nestedValue"
},
key: "value"}
*/

Go Back to Table of Contents

Page 49 of 93

Ni y Snippet: If you try to check if 2 objects with the same proper es are
equal with obj1 = obj2, it will return false. It does this because each object
has its own address in memory as we learned about. The easiest way to
check the contents of the objects for equality is this.
JSON.stringify(obj1) === JSON.stringify(obj2);

This will return true if all proper es are the same.

Type Coercion
Type coercion is the process of conver ng one type of value into another. There are 3
types of conversion in JavaScript.
• to stringx
• to boolean
• to number
let num = 1;
let str = "1";
num == str; // true
// notice loose equality ==, not ===
// double equals (==) will perform a type conversion
// one or both sides may undergo conversions
// in this case 1 == 1 or '1' == '1' before checking equality

Strict equals: The triple equals (===) or strict equality compares two values
without type coercion. If the values are not the same type, then the values
are not equal. This is almost always the right way to check for equality in
JavaScript, so you don't accidentally coerce a value and end up with a bug in
your program. Here is the MDN Equality Comparison page and
the ECMAScript Comparison Algorithm.

ti

Page 50 of 93

ti

ti

ft

Go Back to Table of Contents

There are several edge cases that you will come in contact with in JavaScript as well.
Check out this Comparison Table if you have ques ons about how types are coerced.

Sta c vs Dynamic Typed
The major di erence between sta c and dynamic typed languages is when the types of
variables are checked. Sta c typed languages (Java, C, C++, C#) are checked during the
compile stage, so all types are known before run- me. Dynamic languages (JavaScript,
PHP, Python, Ruby, Perl) are checked on the y, during the execu on stage. Also, a er
dividing the languages into dynamic and sta c, they are then divided again
into strong and weak typed. Weakly typed (JavaScript, PHP, C, C++) languages can make
type coercions implicitly while strongly typed (Python, Ruby, C#, Java) do not allow
conversions between unrelated types.

THE 2 PILLARS: CLOSURES AND PROTOTYPES
Closures and Prototypal Inheritance are two things that make JavaScript special and
di erent from other programming languages.

Func on Constructor
Func ons are objects in JavaScript, which is not true for other languages. Because of
that, they can be called mul ple ways, but they can also be constructors. A func on
constructor creates a new object and returns it. Every JavaScript func on, is actually a
func on object itself.

ft

ti

ti

ti

ti

ti

fl

Page 51 of 93

ti

ti

ti

ti

ff

ti

ti

ti

ti

ff

Go Back to Table of Contents

(function() {}.contructor === Function);
// true
// function constructor
new Function("optionalArguments", "functionBody");
const four = new Function("return four"); // 4
const sum = new Function("x", "y", "return x + y");
console.log(sum(2, 3)); // 5

Almost everything in JavaScript can be created with a constructor. Even basic JavaScript
types like numbers and strings can be created using a constructor.
// examples of constructor functions in JavaScript
const five = new Number(5);
const assignFive = 5;
// this is different than using regular assignment
const newString = new String(`I am a new string`);
const assignString = `I am an assigned string`;
typeof five; // object
typeof assignFive; // number
typeof newString; //object
typeof assignString; // string
five === assignFive; // false
five == assignFive; // true - types are coerced
// Notice how the types are different
// depending on how they are created.
// Arrays, Booleans, Dates, Objects, and Strings
// can be created this way as well.

Go Back to Table of Contents

Page 52 of 93

Prototypal Inheritance
Almost all objects in Javascript pass down proper es through a prototype chain. We call
this chain, prototypal inheritance. The child of the object "inherits" proper es from its
parent. All objects in JavaScript are descended from the Object constructor unless
deliberately created or altered to not do so. The objects inherit methods and proper es
from Object.prototype. The prototype property also has an accessor property
called __proto__ that creates a link between the current object and points to the object
it was created from, the "prototype".
Object.prototype.__proto__;
// null
Object.prototype;
{
__proto__: null;
// ...more methods and properties
}
Object;
// function Object()
// This is the object constructor function
Object.prototype.constructor;
// function Object()
// Points to the constructor
Object.__proto__;
// function () {...}
// Because it is created with a constructor function

Prototype vs __proto__
Understanding the di erence between __proto__ and prototype can be quite a
confusing concept for JavaScript developers. Every func on in JavaScript automa cally
gets a prototype property when it is created that gives it the call, apply, and bind
methods. It doesn't really do anything with regular func ons, but in constructor

ti

ti

ti

ti

ti

Page 53 of 93

ti

ff

Go Back to Table of Contents

func ons the prototype property allows us to add our own methods to the objects we
create. The __proto__ property is what creates the link between prototype objects, the
child inherits proper es from the parent through the prototype chain. Each me a new
object is created in JavaScript, it uses the __proto__ ge er func on to use a built in
constructor func on based on what is being created. This could be an Array, Boolean,
Date, Number, Object, String, Func on, or RegExp. Each one has their own separate
proper es and methods that they inherit from the constructor.

let newArr = new Array
newArr
/* []
{
// all array properties and methods
// inherited from Array constructor function.
length: 0
prototype: {
concat, forEach, pop, splice...
__proto__: Array(0)
prototype: {
__proto__: Object
prototype: {
__proto__: null
}
}
}
}

ti

ti

tt

Page 54 of 93

ti

ti

ti

ti

ti

Go Back to Table of Contents

Callable Object
Because func ons are objects in JavaScript, this also gives them the ability to have
proper es added to them. This creates a callable object, a special object that creates
proper es not available on normal objects. Below is a visualiza on of how this works
under the hood. This code can not be ran in the console, but it is a representa on of
how the object looks.
function say() {
console.log('say something')
}
say.yell = 'yell something'
// under the hood visual
// will not run or show in console
const funcObj = {
// name will not exist if anonymous
name: 'say',
// code to be ran
(): console.log('say something')
// properties get added
// apply, arguments, bind, call, caller, length, name, toString
yell: 'yell something',
}
// with an obj
const obj = {
// nothing gets created
}

ti

Page 55 of 93

ti

ti

ti

ti

Go Back to Table of Contents

Ni y snippet: You might hear people say "Func ons are rst-class ci zens in
JavaScript". All this means is that func ons can be passed around as if they
were a JavaScript type. Anything that can be done with other 7n hhb , can
also be done with func ons. This introduces JavaScript to a whole di erent
type of programming called func onal programming. Below are some
examples of how func ons work di erently in JavaScript.
// setting functions to variables
var setFuncToVar = function () {}
// call function within another
function a(fn) {
fn()
}
a(function () {console.log('a new function')}
// return functions within another
function b() {
return function c() {console.log('another func')}
}

Higher Order Func ons
A Higher Order Func on (HOF) is a func on that either takes a func on as an argument
or returns another func on. There are 3 kinds of func ons in JavaScript.
• func on ()
• func on (a,b)
• func on hof() { return func on () {} }
Instead of wri ng mul ple func ons that do the same thing, remember DRY (don't
repeat yourself). Imagine in the example below, if you separated each code out into
individual func ons how much more code you would be wri ng and how much code
would be repeated.

ti

ff

ti

ti

fi

ti

ti

ti

ti

Page 56 of 93

ff

ti

ti

ti

ti

ti

ti

ti

ti

ti

ti

ti

ti

ti

ti

ft

Go Back to Table of Contents

const giveAccessTo = name => `Access granted to ${name}`;
function auth(roleAmt) {
let array = [];
for (let i = 0; i < roleAmt; i++) {
array.push(i);
}
return true;
}
function checkPerson(person, fn) {
if (person.level === "admin") {
fn(100000);
} else if (person.level === "user") {
fn(500000);
}
return giveAccessTo(person.name);
}
checkPerson({ level: "admin", name: "Brittney" }, auth);
// "Access granted to Brittney"

Take the example below of how you can separate code out and break it down to make it
more reusable.
function multBy(a) {
return function(b) {
return a * b;
};
}
// can also be an arrow function
const multiplyBy = a => b => a * b;
const multByTwo = multiplyBy(2);
const multByTen = multiplyBy(10);
multByTwo(4); // 8
multByTen(5); // 50

Go Back to Table of Contents

Page 57 of 93

Closures
Closures allow a func on to access variables from an enclosing scope or environment
even a er it leaves the scope in which it was declared. In other words, a closure gives
you access to its outer func ons scope from the inner scope. The JavaScript engine will
keep variables around inside func ons that have a reference to them, instead of
"sweeping" them away a er they are popped o the call stack.
function a() {
let grandpa = 'grandpa'
return function b() {
let father = 'father'
let random = 12345 // not referenced, will get garbage collected
return function c() {
let son = 'son'
return `closure inherited all the scopes: ${grandpa} > ${father} > ${son}`
}
}
}
a()()()
// closure inherited all the scopes: grandpa > father > son
const closure = grandma => mother => daughter => return `${grandma} > ${mother} > ${daughter}
`
// grandma > mother > daughter

Page 58 of 93

ff

ti

ti

ft

ti

ft

Go Back to Table of Contents

A Fun Example with Closures:
function callMeMaybe() {
const callMe = `Hey, I just met you!`
setTimeout(function() {
console.log(callMe)
}, 8640000000);
callMeMaybe()
// ONE DAY LATER
// Hey, I just met you!

Do not run this in the console, it takes 1 day to meout!
Two of the major reasons closures are so bene cial are memory e ciency and
encapsula on.

ffi

ti

Page 59 of 93

fi

ti

Go Back to Table of Contents

Memory E cient
Using closures makes your code more memory e cient. Take the example below.
function inefficient(idx) {
const bigArray = new Array(7000).fill("😄 ");
console.log("created!");
return bigArray[idx];
}
function efficient() {
const bigArray = new Array(7000).fill("😄 ");
console.log("created again!");
return function(idx) {
return bigArray[idx];
};
}
inefficient(688);
inefficient(1000);
inefficient(6500);
const getEfficient = efficient();
getEfficient(688);
getEfficient(1000);
getEfficient(6500);
// created!
// created!
// created!
// created Again!
// '😄 '
// inefficient created the bigArray 3 times
// efficient created the bigArray only once

Page 60 of 93

ffi

ffi

Go Back to Table of Contents

Encapsula on
Encapsula on means the restric on of direct access to some of an object's components.
It hides as much as possible of an object's internal parts and only exposes the necessary
parts to run. Why use encapsula on?
• Security - Controlled access
• Hide Implementa on and Expose Behaviours
• Loose Coupling - Modify the implementa on at any me
const encapsulation = () => {
let people = [];
const setName = name => people.push(name);
const getName = idx => people[idx];
const rmName = idx => people.splice(idx, 1);
return {
setName,
getName,
rmName
};
};
const data = encapsulation();
data.setName("Brittney"); // 0
data.getName(0); // 'Brittney'
data.rmName(0); // ['Brittney']
// you have no access to the array people
// can only change it via methods provided

ti

Page 61 of 93

ti

ti

ti

ti

ti

ti

Go Back to Table of Contents

OBJECT ORIENTED PROGRAMMING VS
FUNCTIONAL PROGRAMMING
There are 2 basic philosophies when it comes to how you structure your programs,
object oriented and func onal. Each style has its use in programming, it is not one over
the other, but merely a preference in style.

Object Oriented Programming
Object Oriented Programming, or OOP, is the idea that all code should be grouped into
"boxes" (objects) to make your program easier to read and understand. Keeping the data
encapsulated helps to keep the program organized. Each object has a state that de nes
what it does and methods (func ons on an object) that can use or modify the state.
Considering almost everything in JavaScript is an object, you would think this would be
easy to do. Say we want to create a game that has lots of characters that all have
di erent abili es. How would we go about this?

Page 62 of 93

fi

ti

ti

ti

ff

Go Back to Table of Contents

const elf1 = {
name: 'Dobby',
type: 'house',
weapon: 'cloth',
say: function() {
return `Hi, my name is ${this.name}, I am a ${this.type} elf.`
}
attack: function() {
return `attack with ${this.weapon}`
}
}
const elf2 = {
name: 'Legolas',
type: 'high',
weapon: 'bow',
say: function() {
return `Hi, my name is ${this.name}, I am a ${this.type} elf.`
}
attack: function() {
return `attack with ${this.weapon}`
}
}
elf1.attack()
// attack with cloth
elf2.attack()
// attack with bow

Go Back to Table of Contents

Page 63 of 93

Factory Func ons
As you can see, this code is already ge ng very repe ve and is not maintainable with
only 1 character type. Imagine adding more characters, things would get out of control
quickly. So, another way to create objects was introduced, factory func ons. Factory
func ons return a new object every me they are ran. This could improve the code
somewhat.
function createElf(name, type, weapon) {
return {
name: name,
type: type,
weapon: weapon,
say() {
return `Hi, my name is ${name}, I am a ${type} elf.`;
},
attack() {
return `${name} attacks with ${weapon}`;
}
};
}
const dobby = createElf("Dobby", "house", "cloth");
const legolas = createElf("Legolas", "high", "bow");
dobby.say(); // Hi, my name is Dobby, I am a house elf.
legolas.say(); // Hi, my name is Legolas, I am a high elf.
dobby.attack(); // Dobby attacks with cloth.
legolas.attack(); // Legolas attacks with bow.

ti

ti

ti

tti

Page 64 of 93

ti

ti

ti

Go Back to Table of Contents

Stores
This is a step in the right direc on, but if we added more characters, we would run into
some of the same issues again. Not only is the code not DRY, the a ack method is being
created and taking up memory space for every new elf. This is not very e cient. How do
we solve this? Well, we could separate the methods out into a store.
const elfMethodsStore = {
attack() {
return `attack with ${this.weapon}`;
},
say() {
return `Hi, my name is ${this.name}, I am a ${this.type} elf.`;
}
};
function createElf(name, type, weapon) {
return {
name: name, // old way
type, // with ES6 assignment, if they are the same name
weapon
};
}
// each method has to be assigned to the store method to
// create the __proto__ chain
const dobby = createElf("Dobby", "house", "cloth");
dobby.attack = elfMethodsStore.attack;
dobby.say = elfMethodsStore.say;
const legolas = createElf("Legolas", "high", "bow");
legolas.attack = elfMethodsStore.attack;
legolas.say = elfMethodsStore.say;

ffi

Page 65 of 93

tt

ti

Go Back to Table of Contents

Object.create
Having a store saved us some e ciency in memory, but this was a lot of manual work to
assign each method. So, we were given Object.create to help create this chain without
having to assign each method.
const elfMethodsStore = {
attack() {
return `attack with ${this.weapon}`;
},
say() {
return `Hi, my name is ${this.name}, I am a ${this.type} elf.`;
}
};
function createElf(name, type, weapon) {
// this creates the __proto__ chain to the store
let newElf = Object.create(elfMethodsStore);
console.log(newElf.__proto__); // { attack: [Function], say: [Function] }
// this assigns all the methods
newElf.name = name;
newElf.type = type;
newElf.weapon = weapon;
// this returns the new Elf with everything attached
return newElf;
}
const dobby = createElf("Dobby", "house", "cloth");
const legolas = createElf("Legolas", "high", "bow");
dobby.attack; // attack with cloth
legolas.attack; // attack with bow

Constructor Func ons
Using Object.create is true prototypal inheritance, the code is cleaner and easier to read.
However, you will not see this being used in most programs. Before Object.create came
around, we had the ability to use constructor func ons. Constructor func ons are
exactly like the func on constructor we talked about above. The number and string
func ons were constructed and invoked with the new keyword and they were
capitalized. The new keyword actually changes the meaning of this for the constructor

ti

Page 66 of 93

ti

ffi

ti

ti

ti

Go Back to Table of Contents

func on. Without new, this will point to the window object instead of the object that we
just created. It is best prac ce to capitalize constructor func ons to help us iden fy
them and know to use the new keyword. Proper es added to a constructor func on can
only be done using the this keyword, regular variables do not get added to the object.
// constructor functions are typically capitalized
function Elf(name, type, weapon) {
// not returning anything
// "constructing" a new elf
this.name = name;
this.type = type;
this.weapon = weapon;
}
// to use a constructor function
// the "new" keyword must be used
const dobby = new Elf("Dobby", "house", "cloth");
const legolas = new Elf("Legolas", "high", "bow");
// To add methods we need to add
Elf.prototype.attack = function() {
// cannot be an arrow function
// this would be scoped to the window obj
return `attack with ${this.weapon}`;
};
// This would need to be repeated for each method.
dobby.attack(); // attack with cloth
legolas.attack(); // attack with bow

ti

ti

ti

Page 67 of 93

ti

ti

ti

Go Back to Table of Contents

Ni y Snippet: A constructor func on in JavaScript is actually just a
constructor itself.
// What happens under the hood...
const Elf = new Function(
'name',
'type',
'weapon',
// the \ n just creates a new line
// it can be ignored here
'this.name = name \n
this.type = type \n
this.weapon = weapon`
)
const dobby = new Elf('Dobby', 'house', 'cloth')
// This will work the same as our code above.

Class
Confused yet? Prototype is a li le weird and hard to read unless you really understand
your prototypal inheritance. No one really liked using the prototype way of adding
methods, so in ES6 JavaScript gave us the class keyword. However, classes in JavaScript
are not true classes, they are syntac c sugar. Under the hood, it is s ll using the old
prototype method. They are in fact just "special func ons" with one big di erence,
func ons are hoisted and classes are not. You need to declare your class before it can be
used in your codebase. Classes also comes with a new method, the constructor that
creates and instan ates an object created with class. Classes are able to be extended
upon using the extends keyword, allowing subclasses to be created. If there is a
constructor present in the extended class, the super keyword is needed to link the
constructor to the base class. You can check if something is inherited from a class by
using the keyword instanceof to compare the new object to the class.

ff

ti

ti

Page 68 of 93

ti

ti

tt

ti

ti

ft

Go Back to Table of Contents

class Character {
constructor(name, weapon) {
this.name = name;
this.weapon = weapon;
}
attack() {
return `attack with ${this.weapon}`;
}
}
class Elf extends Character {
constructor(name, weapon, type) {
super(name, weapon);
// pulls in name and weapon from Character
this.type = type;
}
}
class Ogre extends Character {
constructor(name, weapon, color) {
super(name, weapon);
this.color = color;
}
enrage() {
return `double attack power`;
}
}
const legolas = new Elf("Legolas", "high", "bow");
const gruul = new Ogre("Gruul", "club", "gray");
legolas.attack(); // attack with bow
gruul.enrage(); // double attack power
gruul.attack(); // attack with club
legolas instanceof Elf; //true
gruul instanceof Ogre; //true

Go Back to Table of Contents

Page 69 of 93

Private and public elds
Most class based languages have the ability to create either public or private elds
within a class. Adding these to classes in JavaScript is s ll an experimental feature in
development. Support in browsers is limited, but can be implemented with systems like
Babel. Public declara ons are set above the constructor and can be used within the
class, but do not get added to a new instance. The private declara ons are set with
the # sign in front of the variable and are only accessible within that class, they cannot
be accessed or changed from outside.
// public declarations
class Rectangle {
height = 0;
width;
constructor(height, width) {
this.height = height;
this.width = width;
}
}
// private declarations
class Rectangle {
#height = 0;
#width;
constructor(height, width) {
this.#height = height;
this.#width = width;
}
}

So, did we obtain perfect object oriented programming? Well, that is up for debate. It is
really up to you the developer to decide which style of wri ng you like best. We did
learn that object oriented programming helps make you code more understandable,
easy to extend, easy to maintain, memory e cient, and DRY!

fi

ti

ti

ti

Page 70 of 93

ffi

fi

ti

Go Back to Table of Contents

Ni y Snippet: Why didn't Eich just add classes to JavaScript in the
beginning?
"If I had done classes in JavaScript back in May 1995, I would have been told
that it was too much like Java or the JavaScript was compe ng with Java ... I
was under marke ng orders to make it look like Java but not make it too big
for its britches ... [it] needed to be a silly li le brother language." —Brendan
Eich

4 PILLARS OF OOP
• Encapsula on - Organizes code into containers that relate to each other and makes
it easier to maintain and reuse.
• Abstrac on - Hides the complexity from the user by doing the method calcula ons
behind the scenes.
• Inheritance - Gives the proper es of a class to another class, keeping code DRY and
saving on memory space.
• Polymorphism - The ability of an object to take on many forms allowing methods to
be used di erently by di erent classes.

ti

ti

Page 71 of 93

tt

ti

ff

ti

ti

ff

ti

ft

Go Back to Table of Contents

FUNCTIONAL PROGRAMMING
Func onal programming has the same goals in mind as object oriented programming, to
keep your code understandable, easy to extend, easy to maintain, memory e cient, and
DRY. Instead of objects, it uses reusable func ons to create and act on data. Func onal
program is based on a separa on of concerns similar to object oriented programming.
However, in func onal programming there is a complete separa on between the data
and the behaviors of a program. There is also an idea that once something is created, it
should not be changed, being immutable. Unlike OOP, shared state is avoided func onal
programming works on the idea of pure func ons.

Pure Func ons
A pure func on has no side e ects to anything outside of it and given the same input
will always output the same value. They do not change any data passed into them, but
create new data to return without altering the original. However, it is not possible to
have 100% pure func ons. At some point you need to interact with the dom or fetch an
api. Even console.log makes a func on unpure because it uses the window object
outside of the func on. Fact is a program cannot exist without side e ects. So, the goal
of func onal programming is to minimize side e ects by isola ng them away from the
data.
Build lots of very small, reusable and predictable pure func ons that do the following:
•
•
•
•
•
•
•

Complete 1 task per func on.
Do not mutate state.
Do not share state.
Be predictable.
Be composable, one input and one output.
Be pure if possible.
Return something.

Referen al transparency
One important concept of func onal programming is referen al transparency, the
ability to replace an expression with the resul ng value without changing the result of
the program.

ti

ti

ffi

ff

ti

ti

ti

ti

ff

ti

ti

ti

Page 72 of 93

ti

ti

ti

ff

ti

ti

ti

ti

ti

ti

ti

ti

ti

Go Back to Table of Contents

return num1 + num2;
}
function b(num) {
return num * 2;
}
b(a(3, 4)); // 14
// a should always return 7
// so it could be changed to
b(7); // 14
// and the output is the same

Idempotence
Idempotence is another important piece of func onal programming. It is the idea that
given the same input to a func on, you will always return the same output. The func on
could be used over and over again and nothing changes. This is how you make your code
predictable.

Impera ve vs Declara ve
Impera ve programming tells the computer what to do and how to complete it.
Declara ve programming only tells the computer what to do, but not how to do things.
Humans are declara ve by nature, but computers typically need more impera ve type
programming. However, using higher level languages like JavaScript is actually being less
declara ve. This is important in func on programming because we want to be more
declara ve to be er understand our code and let the computer handle the dirty work of
guring out the best way to do something.

ti

ti

ti

Page 73 of 93

ti

ti

ti

ti

tt

ti

ti

ti

ti

Go Back to Table of Contents

ti

fi

function a(num1, num2) {

// more imperative
for (let i = 0; i < 10; i++) {
console.log(i);
}

// more declarative
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.forEach(item => console.log(item));

Go Back to Table of Contents

Page 74 of 93

Immutability
Immutability is simply not modifying the original data or state. Instead we should create
copies of the state inside our func ons and return a new version of the state.
// Bad code
const obj = {name: 'Brittney'}
function clone(obj) {
return {...obj} // this is pure
}
obj.name = 'Joe' //mutated the state
// Better code
function updateName(obj) {
const newObj = clone(obj)
newObj.name = 'Joe'
return newObj
}
const updatedNameObj = updateName(obj)
console.log(`obj = ${obj}`, `updatedNameObj = ${updatedNameObj})

You may be thinking that this could get really expensive, memory wise, to just copy code
over and over. However, there is something called structural sharing that allows the data
to only copy new informa on and points to the original state for any commonali es.

Page 75 of 93

ti

ti

ti

Go Back to Table of Contents

Par al Applica on
Par al applica on is expanding on the idea of currying and taking it a step farther by
separa ng a parameter out. If you have more than 2 arguments in a func ons, then you
can bind one of them to a value to be used later.
const multiply = (a, b, c) => a * b * c;
const curriedMultiplyBy5 = multiply.bind(null, 5); // this is null
curriedMultiplyBy5(4, 10); // 200

Pipe and Compose
In JavaScript it is best for speed and e ciency to keep func ons small and reusable.
Func on composi on is the idea that you lay out your func ons like a factory assembly
line. The actual func ons pipe() and compose() don't actually exist in JavaScript yet, but
there are many libraries that use them. You can however create your own versions of
them. The compose() func on reads the func ons from right to le and
the pipe() func on will read from le to right.
// create our own COMPOSE function
const compose = (fn1, fn2) => data => fn1(fn2(data));
// create our own PIPE function
const pipe = (fn1, fn2) => data => fn2(fn1(data));
const multiplyBy3 = num => num * 3;
const makePositive = num => Math.abs(num);
// use compose to combine multiple functions
const composeFn = compose(multiplyBy3, makePositive);
const pipeFn = pipe(multiplyBy3, makePositive);
composeFn(-50); // 150
pipeFn(-50); // 150
// essentially we are doing this
// fn1(fn2(fn3(50)))
// compose(fn1, fn2, fn3)(50)
// pipe(fn3, fn2, fn1)(50)

ti

ft

ti

ti

ti

ffi

Page 76 of 93

ft

ti

ti

ti

ti

ti

ti

ti

ti

ti

ti

Go Back to Table of Contents

Ni y Snippet: The Pipeline Operator is in the experimental stage 1 of being
introduced to JavaScript. Stage 1 means that it has only started the process
and could be years before it is a part of the language. The pipeline
operator, |>, would be syntac c sugar for composing and piping func ons
the long way. This would improve readability when chaining mul ple
func ons.
const double = n => n * 2;
const increment = n => n + 1;
// without pipeline operator
double(increment(double(double(5)))); // 42
// with pipeline operator
5 |> double |> double |> increment |> double; // 42

Arity
Arity simply means the number of arguments a func on takes. The more parameters a
func on has the harder it becomes to break apart and reuse. Try to s ck to only 1 or 2
parameters when wri ng func ons.

Reviewing Func onal Programming
So, is func onal programming the answer to everything? No, but it is great in situa ons
where you have to perform di erent opera ons on the same set of data. Func onal
programming just lays the founda on for crea ng reusable func ons that can be moved
around as needed. For example, it is great in areas of industry and machine learning and
it is even in some front end libraries like React and Redux. Redux really popularized
func onal programming for JavaScript developers. I'll leave you with one more example,
a basic shopping cart (next page).

ti

ti

ti

ti

ti

ti

ti

ti

Page 77 of 93

ti

ti

ti

ff

ti

ti

ti

ti

ti

ti

ti

ft

Go Back to Table of Contents

const user = {
name: "Kim",
active: true,
cart: [],
purchases: []
};
const userHistory = [];
function addToCart(user, item) {
userHistory.push(
Object.assign({}, user, { cart: user.cart, purchases: user.purchases })
);
const updateCart = user.cart.concat(item);
return Object.assign({}, user, { cart: updateCart });
}
function taxItems(user) {
userHistory.push(
Object.assign({}, user, { cart: user.cart, purchases: user.purchases })
);
const { cart } = user;
const taxRate = 1.4;
const updatedCart = cart.map(item => {
return {
name: item.name,
price: item.price * taxRate
};
});
return Object.assign({}, user, { cart: updatedCart });
}
function buyItems(user) {
userHistory.push(
Object.assign({}, user, { cart: user.cart, purchases: user.purchases })
);
return Object.assign({}, user, { purchases: user.cart });
}
function emptyCart(user) {
userHistory.push(
Object.assign({}, user, { cart: user.cart, purchases: user.purchases })
);
return Object.assign({}, user, { cart: [] });
}
function refundItem(user, item) {
userHistory.push(
Object.assign({}, user, { cart: user.cart, purchases: user.purchases })
);
const { purchases } = user;
const refundItem = purchases.splice(item);
return Object.assign({}, user, { purchases: refundItem });
}
const compose = (fn1, fn2) => (...args) => fn1(fn2(...args));
const purchaseItems = (...fns) => fns.reduce(compose);
purchaseItems(
emptyCart,
buyItems,
taxItems,
addToCart
)(user, { name: "laptop", price: 200 });
refundItem(user, { name: "laptop", price: 200 });

Go Back to Table of
console.log(userHistory);

Contents

Page 78 of 93

COMPOSITION VS INHERITANCE
Composi on is what we just did with FP, crea ng small reusable func ons to make code
modular. Inheritance is what we did with OOP, crea ng a class and extending it to
subclasses that inherit the proper es. In OOP we create few opera ons on common data
that is stateful with side e ects. In FP we create many opera ons on xed data with pure
func ons that don't mutate state. There is a big debate over which one is be er and
most people believe that composi on is be er.

OOP Problems
One of the drawbacks to inheritance is that it is based on the fact that it won't change,
we tell it what it is. We create a class and give it proper es and methods that describe
the class. But say, down the road, we need to update that class and add more
func onality. Adding a new method to the base class will create rippling e ects through
your en re program. FP is more declara ve, what to do not how, and OOP is more
impera ve, what and how to do something. This is the ght coupling problem, things
having to depend on one another, which leads to the fragile base class problem,
seemingly safe changes cause unforeseen repercussions. It is the opposite of small
reusable code. Changing one small thing in either of the class or subclasses could break
the program. Another problem is hierarchy where you may need to create a subclass
that can only do 1 part of the class, but instead you get everything passed down to it.

Finally
Composi on is probably a be er tool to use when crea ng programs because it creates
a more stable environment that is easier to change in the future. The key is to decide
which structure is be er for your project. You can use ideas from both of these styles to
write your code. React uses OOP in class components to extend inheritance and then
uses FP in the pure components.

tt

ff

ti

fi

ti

ti

ti

ti

ti

ti

ti

tt

Page 79 of 93

ti

ti

ti

tt

ff

tt

ti

ti

ti

ti

ti

ti

Go Back to Table of Contents

MODULES IN JAVASCRIPT
Modules are pieces of code, grouped together, that can be combined together to create
an expandable program that can get bigger as it needs to. Good modules are self
contained and grouped together with their own speci c func onality allowing them to
be moved or deleted without breaking the program.

Module Pa erns
Originally in JavaScript, we had the module pa ern. Before block scope came around,
there was only global scope and func on scope. To create this idea of modules,
a module scope was implemented just above the func on scope. This allowed variables
to be shared, by expor ng and impor ng, between the func ons without having to go
through the global scope. A func on as a module is essen ally just an immediately
invoked func on expression, IIFE.
var globalScopeVar = "I can be accessed anywhere";
var moduleName = (function(globalScopeVar) {
// add private variables here
var privateVar = "I cannot be accessed outside";
// create the function
function say(msg1, msg2) {
var say1 = Math.floor(Math.random() * msg1.length);
var say2 = Math.floor(Math.random() * msg2.length);
return say1 > say2 ? say1 : say2;
}
globalScopeVar = `I don't change the outside scope`;
// return only what you want the outside to access
return {
say: say
};
})(globalScopeVar);

ti

ti

ti

ti

fi

tt

ti

Page 80 of 93

ti

ti

ti

tt

ti

Go Back to Table of Contents

Issues with Modules
Even though modules help us to contain and organize code, there are s ll problems that
can arise. There can be naming con icts if you don't use const to declare the module.
Also, there are dependency issues if scripts are placed in the wrong order, such as jQuery
needing to be called before it can be used. Because of these problems, people started
developing libraries to solve them. Before ES6 we had 2 ways to implement modules in
JavaScript CommonJS and AMD.
• CommonJS - uses the keywords require and exports to interact with the module
system. Require is a func on used to import from another module and exports is an
object where func ons get exported from. These are run synchronously where we
wait on one module to load before another can start and this is not ideal for browsers.
However, this code may look familiar because NodeJS s ll uses this library. There are
other packages such as Browserify and webpack that aid in bundling scripts with
CommonJS to be used in the browsers.
• Asynchronous Module De ni on (AMD) - as in the name, AMD loads modules
asynchronously. This was great for browsers early on before packages that bundled
code.
de ne(['module1', 'module2'], func on(module1, module2)
{console.log(module1.setName());});
The de ne func on takes an array of dependency modules that are loaded in a nonblocking manner in the background. Once completed, the callback func on is then
executed. Packages came out like RequireJS that implemented the AMD endpoint and
was the main way people used AMD modules.

ES6 Modules
A er ES6 came out, pre y much everything above was thrown out the window with 2
new keywords. We can now use the import and export keywords in our les to
implement modules. This again may look familiar from popular frameworks like React.
import module1 from "module1";
import module2 from "module2";
export function name() {}

fi

ti

ti

ti

ti

Page 81 of 93

fl

ti

fi

ti

tt

ti

ti

fi

fi

ft

Go Back to Table of Contents

Here is our module code from above in the new ES6 syntax.
const privateVar = "I cannot be accessed outside this file";
export function name(msg1, msg2) {
const say1 = Math.floor(Math.random() * msg1.length);
const say2 = Math.floor(Math.random() * msg2.length);
return say1 > say2 ? say1 : say2;
}

There are 2 types of exports, named and default. A named export is imported using curly
braces ({ importFnName }) and a default func on is added in created like this:
import { importFnName } from "./script.js";
// with a default function the {} are not needed
import name from "./script.js";
// both default and named function import
import name, { importFnName } from "./script.js";
export default function name(msg1, msg2) {
const say1 = Math.floor(Math.random() * msg1.length);
const say2 = Math.floor(Math.random() * msg2.length);
return say1 > say2 ? say1 : say2;
}

Trying to run this in the browser there is s ll 2 more things that have to be done. You
have to declare the type in the html script tag as module and the le has to be served
from a server. You can spin up your own server with a package like live-server on npm.
<script type="module" src="'./script.js'></script>

Go Back to Table of Contents

fi

ti

ti

Page 82 of 93

ERROR HANDLING
One of the most important things to learn in being a developer is how to solve errors.
Learning to handle errors makes you a be er programmer. Wri ng your programs you
have the ability to use the throw keyword to stop the program and handle an error by
using a try/catch block that has an op onal nally block or the .catch() method for
asynchronous code. Throwing a new error in asynchronous code gets what is called a
silent fail if there is no catch block present. In synchronous code, if there is no catch
statement placed in the code, the run me will create catch: onerror() and we see the
built in JavaScript error message in red (see next page).

Go Back to Table of Contents

ti

fi

tt

ti

ti

Page 83 of 93

throw new Error();
// synchronous try/catch/finally block
function fail() {
try {
console.log("this works");
throw new Error("oopsie!!!");
} catch (error) {
console.log("we have made an oopsie", error);
} finally {
console.log("still good");
}
}
fail();
// this works // because it goes line by line
// we have made an oopsie Error: oopsie at fail
// still good
// asynchronous .catch()
Promise.resolve("asyncfail")
.then(response => {
console.log(response);
return response;
})
.catch(error => {
console.log(err);
});
(async function() {
try {
await Promise.resolve("oopsie #1");
await Promise.reject("oopsie #2");
} catch (err) {
console.log(err);
}
console.log("is this still good?");
})();
// Promise {} // Promise resolved
// ooopsie #2
// is this still good?

Go Back to Table of Contents

Page 84 of 93

Besides the generic Error constructor, there are seven other built in error constructors.
• EvalError - an error with the global func on eval().
• InternalError - an error in the JavaScript engine is thrown. Usually when something
is too large.
• RangeError - an error when a numeric variable or parameter is outside of its valid
range.
• ReferenceError - an error that occurs when referencing something invalid. E.g.
When a variable is used before it is declared.
• SyntaxError - an error that occurs in parsing, the engine does not understand what
is wri en.
• TypeError - an error when a variable is not the correct type.
• URIError - an error when encodeURI() or decodeURI() are passed invalid
parameters.
Errors created using the new keyword come with 3 proper es.
• name - the name of the error.
• message - the parameter given to the error.
• stack - the stack trace or callback queue when the error occurred that also includes
the line and character number where the error happened.
const myError = new Error("oopsie");
myError.name; // "Error"
myError.message; // "oopsie"
myError.stack; // "Error: oopsie at <anonymous>:1:17
function a() {
const b = new Error("uh oh");
return b;
}
b(); // b().stack
// Error: uh oh
// at a (<anonymous>:2:12)
// at <anonymous>:1:1

ti

Page 85 of 93

ti

tt

Go Back to Table of Contents

Because Error is a constructor func on, we can use that to extend it and add to it. You
don't want to reveal parts of your program by allowing an error to give the stack trace
and other informa on to possible bad actors. So, you can customize what you want your
errors to reveal.
class AuthenticationError extends Error {
constructor(message) {
super(message);
this.name = "AuthenticationError";
this.message = "authentication problem";
this.fix = "please log in";
}
}
const err = new AuthenticationError("oopsie");
err; // authenticationError: "authentication problem" stack trace
err.fix; // please log in

THE END…
This is the "o cial" end of the Advanced JavaScript sec on, but Bri ney added a small
sec on of her notes on data structures and algorithms because they are an important
part of developing great programs.

DATA STRUCTURES & ALGORITHMS
Data structures and algorithms are the fundamentals of every program. Data structures
are collec ons of values and algorithms are the steps we put in place to manipulate the
data structures. No ma er what language you write in if you understand these 2 things,
you have the ability to write great programs.

tt

ti

Page 86 of 93

ti

tt

ti

ffi

ti

ti

Go Back to Table of Contents

Data Structures
A data structure is di erent types of containers that hold your data. Each container has
its own type of data it holds and its speci c to that type. You want to be able to easily
access your data and know where it is located. It is basically a way to organize your data.
There are 2 parts to data structures, how to build one and how to use it.

How do computers work?
A computer has many parts but 3 that run almost all of our everyday opera ons, the
CPU, RAM, and a hard drive (storage). The CPU processes all the data and only has so
much power, the RAM is memory that is temporarily delegated to programs, and a hard
drive is persistent memory that stays where we put it. Persistent storage is quiet slow, so
we need RAM to use as a temporary holder for memory. RAM is like a storage shelf of
memory addresses that each contain 8 bits or 1 byte. Each bit is either a 0 or a 1 to
indicate whether it is on or o , 1 for on and 0 for o .

Popular Data Structures
There are many implementa ons of data structures out there but there are only 2
fundamental kinds, array of con guous memory loca ons and linked structures, or you
can combine the two. The most important ones you will run into are arrays, stacks,
queues, linked lists, trees, tries, graphs, and hash tables. With algorithms there are
sor ng, dynamic programming, BFS + DFS (Searching), and recursion. Each data structure
has things they are good at and may be be er in certain situa ons than others. Below is

ti

ti

ti

ff

tt

Page 87 of 93

fi

ti

ff

ti

ff

ti

Go Back to Table of Contents

Arrays
Arrays order items sequen ally with an index. Arrays are probably the simplest and the
most widely used data structure because the are fast and take up the least amount of
space. They also have the least amount of rules. Array methods have di erent me
complexi es, called Big-Order or Big-O nota ons. _O(1) is constant me, meaning the
me does not change with the data input. The _O(n) is linear me, meaning me
changes or goes up the more opera ons that need to be performed. _O(1) can end up as
_O(n) in languages like JavaScript if it needs to allocate more memory for the array.
There is also, Big-Omega or Big-Ω nota on that give the best possible me for your

ti

ti

ff

ti

ti

ti

ti

ti

Page 88 of 93

ti

ti

Go Back to Table of Contents

ti

ti

a list of data structures that are built into several popular languages. That doesn't mean
that you can't use other types, you just have to build our own. Such as if JavaScript
doesn't have stacks, we can build one.

program. If a program has the same me complexity in Big-O and in Big-Ω, then you can
use θ as shorthand for both combined.
const strings = ["a", "b", "c", "d"];
// 4 * 4 = 16 bytes of storage
strings[2]; // c // O(1)
strings.push("e"); // O(1)
// ['a', 'b', 'c', 'd', 'e']
strings.pop(); // O(1)
// ['a', 'b', 'c', 'd']
strings.unshift("z"); // O(n)
// ['z', 'a', 'b', 'c', 'd']
// unshift took 5 operations to complete.
// ['a', 'b', 'c', 'd']
// [ 0

1

2

3 ] all indexes need to shift

// ['z', 'a', 'b', 'c', 'd']
// [

0

1

2

3 ]

// [ 0

1

2

3

4 ]

Implemen ng an Array
Arrays can be declared easily in JavaScript, but what if we built our own…

Page 89 of 93

ti

ti

Go Back to Table of Contents

class MyArray {
constructor() {
this.length = 0;
this.data = {};
}
get(index) {
return this.data[index];
}
push(item) {
this.data[this.length] = item;
this.length++;
return this.length;
}
pop() {
const lastItem = this.data[this.length - 1];
delete this.data[this.length - 1];
this.length--;
return lastItem;
}
delete(index) {
const item = this.data[index];
this.shiftItems(index);
return item;
}
shiftItems(index) {
for (let i = index; i < this.length; i++) {
this.data[i] = this.data[i + 1];
}
delete this.data[this.length - 1];
this.length--;
}
}
const newArray = new MyArray();
newArray.push("hi");

Go Back to Table of Contents

Page 90 of 93

Hash Tables
Di erent languages have di erent names for a hash table, but in JavaScript a hash table
is an object. A data structure that stores data in key/value pairs.

Hash Func on
A hash func on takes a key and maps it to a value of xed length for every input. It is an
idempotent func on meaning given the same input the output will always be the same.
A hash table uses the hash func on to compute the key into a hash code and map that
to an address in memory where it is stored with the value in a bucket. Using the hashing
technique makes looking up data inside the hash table very fast and is usually O(1) me.
let character = {
age: 20,
name: "Harry Potter",
muggle: false,
patronus: function() {
console.log("Expecto Patronum!");
}
};
character.age; // 20 // O(1)
character.levitate = "Wingardium Leviosa!"; // O(1)
character.patronus(); // Expecto Patronum! // O(1)

Hash Collisions
Every data structure is going to come with downsides. Hash collisions are what happens
when a hash func on maps a key to the same address as a previously added key. With
enough data and limited memory, we will always run into this collision. This does not
overwrite the previous informa on, but creates a linked list and slows down our ability
to access the informa on. Your big O nota on me jumps from O(1) to O(n/k) where n is
the me and k is the size of the hash table.

ti

fi

ti

Page 91 of 93

ti

ti

ti

ff

ti

ti

ti

ti

ti

ti

ff

Go Back to Table of Contents

Hashing in JavaScript
JavaScript came out with 2 ways to help prevent hash collisions when implemen ng
hash tables, the Map object and the Set. Map will store key/value pairs like an object,
but will remember the original order in memory. A Map also allows for any data type to
be stored as a key such as an array or func on. A Set will only store the values and also
remembers the original order, but the values may only occur once.

Create a Hash Table
(con nued on next page)

ti

Page 92 of 93

ti

ti

Go Back to Table of Contents

class HashTable {
constructor(size) {
this.data = new Array(size);
// this.data = [];
}
_hash(key) {
let hash = 0;
for (let i = 0; i < key.length; i++) {
hash = (hash + key.charCodeAt(i) * i) % this.data.length;
}
return hash;
}
set(key, value) {
let address = this._hash(key);
if (!this.data[address]) {
this.data[address] = [];
}
this.data[address].push([key, value]);
return this.data;
}
get(key) {
const address = this._hash(key);
const currentBucket = this.data[address];
if (currentBucket) {
for (let i = 0; i < currentBucket.length; i++) {
if (currentBucket[i][0] === key) {
return currentBucket[i][1];
}
}
}
return undefined;
}
keys() {
const keysArray = [];
for (let i = 0; i < this.data.length; i++) {
if (this.data[i]) {
keysArray.push(this.data[i][0][0]);
}
}
return keysArray;
}
}
const myHashTable = new HashTable(50);
myHashTable.set("grapes", 10000);
myHashTable.get("grapes");
myHashTable.set("apples", 9);
myHashTable.get("apples");
myHashTable.keys();

Go Back to Table of Contents

Page 93 of 93

